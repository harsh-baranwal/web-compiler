<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
    <script src="moo.js"></script>
    <script src="nearley.js"></script>
    <script src="generate.js"></script>
    <script src="compile.js"></script>
    <title>EmojiScript 🔥</title>
</head>
<body bgcolor="#1e1e20">
    <div class="hero">
        <div class="image-container">
            <img src="logo.svg" alt="Logo">
            <div class="glow"></div>
        </div>
        <div class="text-container">
            <h1>EmojiScript</h1>
            <h3>A new programming language<br>based on emojis.</h3>
            <p onclick="cliCopy()" title="Click to copy" class="cli">npm i -g the-emojiscript</p><br>
            <a href="#doc" class="start">Get Started</a>
            <a target="_blank" href="https://github.com/harsh-baranwal/the-emojiscript" class="git">View on Github</a>
        </div>
    </div>
    <span id="copied">Copied ✂️</span>
    <div class="credit">
        <p>Made with <span style="user-select: none; color: red;">❤️</span> by <a class="profile" href="https://linkedin.com/in/harshbaranwal" target="_blank">Harsh Baranwal</a></p>
    </div>

    <div class="editor-div">
        <h1>Editor 🛠️</h1>
        <div class="line-numbers">
            <span></span>
        </div>
    
<textarea name="editor" id="editor" spellcheck="false" autocapitalize="false">
a ➡️ 6
🌀 i ➡️ 1, 10, 1 👉
    🔊"Hello World!"❗
    🤔 i==a 👉
        🔊"Value is: " 🔗 a❗
    👈
👈
</textarea>
        <button onclick="output()" title="Run" id="run">💣</button>
        <button onclick="javascript:eraseText();" title="Clear" id="clear">🧹</button>
        <div id="output">
            <p style="text-align: center;">Hurray! 🎉</p><br>
            <p id="output-text"></p>
        </div>
    </div>

    <div class="doc-div" id="doc">
        <h1>Documentation 📃</h1><br>
        <p style="text-align: center; margin-bottom: 15px;">Follow these steps to install emojiscript in your system as per instructions given below.</p>
        
        <div class="topbar">
            <menu id="toggleMenu">
                <span></span>
                <span></span>
                <span></span>
                <p>Menu</p>
            </menu>
        </div>

        <!-- <div id="overlay"></div> -->

        <div class="sidebar" id="sidebar">
            <a href="#install">Installation</a>
            <a href="#quick">Quick Start</a>
            <a href="#comments">Comment</a>
            <a href="#print">Print Function</a>
            <a href="#variable">Variable</a>
            <a href="#ifelse">Conditional</a>
            <a href="#forloop">For Loop</a>
            <a href="#while">While Loop</a>
            <a href="#function">Function</a>
            <a href="#builtin">Built-In Functions</a>
        </div>

        <div class="content">
            <h3 id="install">Installation</h3>

            <p>Make sure you have already installed <a class="doc-link" href="https://nodejs.org/en/download">Node.js</a> in your system. Write the following command in your terminal.</p>
            <div class="codeblock"> <span style="user-select: none; color: #9e9e9e;">C:\> </span><span class="yellow">npm</span><span class="cyan"> i -g the-emojiscript</span></div>
            <p>This will make emojiscript globally available for you with command line tool also.</p><br>

            
            <h3 id="quick" >Quick Start</h3>

            <p>To check whether it is installed properly or not run <span class="code">emojiscript</span> command on terminal. Now create a new file and save it with <span class="code">.🔥</span> or <span class="code">.emoji</span> extension and write some peice of code.</p>
            <p>Assume that your file named is <span class="code">script.emoji</span>, to compile and run this file type following command in your terminal.</p>
            <div class="codeblock"><span style="user-select: none; color: #9e9e9e;">$ </span>👀 <span class="cyan">script.emoji</span></div>
            <p>or</p>
            <div class="codeblock"><span style="user-select: none; color: #9e9e9e;">$ </span><span class="yellow">emorun</span> <span class="cyan">script.emoji</span></div>
            
            <h3 id="comments">Comment</h3>

            <p>EmojiScript supports single-line comments, begins with <span class="code">💬</span>. Everything after <span class="code">💬</span> is ignored by the compiler.</p>
            <div class="codeblock"><span class="gray">💬 This is a comment</span><br><span class="gray">💬 This is another comment</span></div>

            <h3 id="print">Print Function</h3>
            <p>To print the output, there is a builtin function that starts with <span class="code">🔊</span> and end with <span class="code">❗</span>. Everything between this keyword will print the output as shown below.</p>

            <div class="codeblock">🔊 <span class="green">"Hello, World"</span> ❗<br><br><span class="red">name</span> <span class="gray">=</span> <span class="green">"Parth"</span><br>🔊 <span class="green">"Hello, "</span> 🔗 <span class="blue">name</span> ❗</div>

            <h3 id="variable">Variable & Data Types</h3>
            <p>You can define variables using <span class="code">➡️</span>. Numbers and strings are like other languages, but null can be denoted as <span class="code">😶</span>. <span class="code">💯</span> and <span class="code">😞</span> are the boolean value.</p>

            <div class="codeblock"><span class="red">a</span> ➡️ <span class="darkyellow">10</span><br><span class="red">b</span> ➡️ <span class="darkyellow">20</span><br><span class="red">sum</span> ➡️ <span class="orange">a + b</span><br><span class="red">text</span> ➡️ <span class="green">"This is string"</span><br><span class="red">c</span> ➡️ 😶<br><span class="red">bool</span> ➡️ 💯<br><span class="red">bool</span> ➡️ 😞</div>

            <h3 id="ifelse">Conditional</h3>
            <p>EmojiScript supports if-else ladder construct, <span class="code">🤔</span> block will execute if condition is true otherwise <span class="code">😌</span> will execute else block.</p>

            <div class="codeblock"><span class="red">a</span> ➡️ <span class="darkyellow">10</span><br> 🤔 <span class="orange">a%2 == 0</span> 👉<br>&nbsp; &nbsp; 🔊 <span class="blue">a</span> 🔗 <span class="green">"is a even number"</span> ❗<br>👈<br>😌 👉<br>&nbsp; &nbsp; 🔊 <span class="blue">a</span> 🔗 <span class="green">"is a odd number"</span> ❗<br>👈</div>

            <h3 id="forloop">For Loop</h3>
            <p>It supports both loops, statements inside <span class="code">🌀</span> blocks are executed as long as a specified condition evaluates to true. Once the statement become false it will break.</p>

            <div class="codeblock">🌀 <span class="blue">i</span> ➡️ <span class="darkyellow">1, 10, 1</span> 👉<br>&nbsp; &nbsp; 🔊 <span class="green">"Hello, World"</span> ❗<br>👈</div>

            <h3 id="while">While Loop</h3>
            <p><span class="code">🤗</span> blocks are executed as long as a specified condition evaluates to true.</p>

            <div class="codeblock"><span class="red">i</span> ➡️ <span class="darkyellow">1</span><br>🤗 <span class="orange">i<10</span> 👉<br>&nbsp; &nbsp; 🔊 <span class="green">"Hello, World"</span> ❗<br>&nbsp; &nbsp; <span class="blue">i++</span><br>👈</div>

            <h3 id="function">Function</h3>
            <p>You can also make functions in EmojiScript through <span class="code">🌏</span> and similar emoji arguments only passed after <span class="code">🤌</span>.</p>

            <div class="codeblock">🌏 <span class="voilet">myFun</span> 🤌 <span class="blue">x, y</span><br>&nbsp; &nbsp; 🙏 <span class="orange">x + y</span><br><br><span class="voilet">myFun</span> 🤌 <span class="blue">10, 20</span> &nbsp; &nbsp; <span class="gray">💬 Calling a function</span></div>

            <h3 id="builtin">Built-In Functions</h3>
            <p>There are some builtin math functions <span class="code">⚡</span> is for power function, <span class="code">🟥</span> for square root and <span class="code">🪵</span> for log function.</p>

            <div class="codeblock" id="built">⚡ <span class="darkyellow">3, 2</span> ❗<br>🟥 <span class="darkyellow">49</span> ❗<br>🪵 <span class="darkyellow">10</span> ❗</div>
            
        </div>
    </div>
    <div class="footer">
        <p>Copyright © 2023 EmojiScript</p>
    </div>
</body>





<script>
let lexer = moo.compile({
    WS:      /[ \t]+/,
    comment: /💬.*?$/,
    number: /[0-9]+(?:\.[0-9]+)?/,
    string:  /"(?:\\["\\]|[^\n"\\])*"/,
    lparen:  '(',
    rparen:  ')',
    operator: /(?:==)|(?:>=)|(?:<=)|(?:!=)|[\+\-\*\/\>\=\<\.\%]/,
    sp_assign: '➡️',
    comma:   ',',
    colon: ':',
    identifier: /[a-zA-Z][a-zA-Z_0-9]*/,
    keyword: ['🔊', '🎤', '👉', '👈', '❗', '🤔', '😌', '🌀', '🤗', '💯', '😞', '🙏', '😶', '🚫', '😁', '🤌', '🍰', '🔗'],
    credits: ['👦', '👑'],
    fun_keywords: ['🌏', '🌍', '🌎'],
    math_fun: ['⚡', '🟥', '🪵', '🧮', '🍕', '🍰'],
    NL:  { match: /[\r\n]+/, lineBreaks: true },
});

(function () {
function id(x) { return x[0]; }

const myLexer = lexer;
var grammar = {
    Lexer: myLexer,
    ParserRules: [
    {"name": "lines", "symbols": ["line"], "postprocess": id},
    {"name": "lines", "symbols": ["lines", (myLexer.has("NL") ? {type: "NL"} : NL), "line"], "postprocess": 
        (data) => {
            return [...data[0], ...data[2]];
        }
                },
    {"name": "line", "symbols": ["_", "statement", "_"], "postprocess": 
        (data) => {
            return [data[1]];
        }
                },
    {"name": "line", "symbols": ["_"], "postprocess": 
        () => []
                },
    {"name": "statement", "symbols": ["var_assign"], "postprocess": id},
    {"name": "statement", "symbols": ["print_fun"], "postprocess": id},
    {"name": "statement", "symbols": ["return_fun"], "postprocess": id},
    {"name": "statement", "symbols": ["fun_call"], "postprocess": id},
    {"name": "statement", "symbols": [(myLexer.has("comment") ? {type: "comment"} : comment)], "postprocess": id},
    {"name": "statement", "symbols": ["if_statement"], "postprocess": id},
    {"name": "statement", "symbols": ["for_loop"], "postprocess": id},
    {"name": "statement", "symbols": [(myLexer.has("credits") ? {type: "credits"} : credits)], "postprocess": id},
    {"name": "statement", "symbols": ["fun_def"], "postprocess": id},
    {"name": "statement", "symbols": ["break"], "postprocess": id},
    {"name": "statement", "symbols": ["while"], "postprocess": id},
    {"name": "statement", "symbols": ["continue"], "postprocess": id},
    {"name": "var_assign", "symbols": [(myLexer.has("identifier") ? {type: "identifier"} : identifier), "_", {"literal":"➡️"}, "_", "expr"], "postprocess": 
        (data) => {
            return {
                type: "var_assign",
                var_name: data[0],
                value: data[4]
            }
        }
                            },
    {"name": "var_assign", "symbols": [(myLexer.has("identifier") ? {type: "identifier"} : identifier), "_", {"literal":"="}, "_", "input_fun"], "postprocess": 
        (data) => {
            return {
                type: "input_assign",
                var_name: data[0],
                value: data[4]
            }
        }
                      },
    {"name": "return_fun", "symbols": [{"literal":"🙏"}, "__", "expr"], "postprocess": 
        (data) => {
            return {
                type: "return_fun",
                value: data[2],
            }
        }
                        },
    {"name": "input_fun", "symbols": [{"literal":"🎤"}, "_", (myLexer.has("string") ? {type: "string"} : string), "_", {"literal":"❗"}], "postprocess": 
        (data) => {
            return {
                type: "input_fun",
                value: data[2],
            }
        }
                        },
    {"name": "print_fun", "symbols": [{"literal":"🔊"}, "_", "print_val", "_", {"literal":"❗"}], "postprocess": 
        (data) => {
            return {
                type: "print_fun",
                value: data[2],
            }
        }
            },
    {"name": "print_val", "symbols": ["expr"], "postprocess": id},
    {"name": "print_val", "symbols": [], "postprocess": 
        (data) => {
            return {
                value: '"😶"',
            }
            }
        },
    {"name": "print_val", "symbols": ["print_val", "_", {"literal":"🔗"}, "_", "expr"], "postprocess": 
        (data) => {
            return [
                data[0] + data[2] + data[4]
            ]
        }
                     },
    {"name": "codeblock", "symbols": [{"literal":"👉"}, "lines", {"literal":"👈"}], "postprocess": 
        (data) => {
            return {
                type: "codeblock",
                statements: data[1]
            }
        }
                        },
    {"name": "if_statement", "symbols": [{"literal":"🤔"}, "__", "expr", "__", "codeblock"], "postprocess": 
        (data) => {
            return {
                type: "if_statement",
                cond: data[2],
                code: data[4]
            }
        }
                            },
    {"name": "if_statement", "symbols": [{"literal":"🤔"}, "__", "expr", "__", "codeblock", "__lb", {"literal":"😌"}, "__", "codeblock"], "postprocess": 
        (data) => {
            return {
                type: "if_statement",
                cond: data[2],
                code: data[4],
                alt: data[8]
            }
        }
                        },
    {"name": "if_statement", "symbols": [{"literal":"🤔"}, "__", "expr", "__", "codeblock", "__lb", {"literal":"😌"}, "__", "if_statement"], "postprocess": 
        (data) => {
            return {
                type: "if_statement",
                cond: data[2],
                code: data[4],
                alt: data[8]
            }
        }
                        },
    {"name": "arglist", "symbols": [{"literal":"🤌"}, "_"], "postprocess": () => []},
    {"name": "arglist", "symbols": [{"literal":"🤌"}, "__", "fun_param"], "postprocess": 
        (data) => data[2]
                   },
    {"name": "fun_param", "symbols": ["expr"], "postprocess": id},
    {"name": "fun_param", "symbols": ["fun_param", "_", {"literal":","}, "_", "expr"], "postprocess": 
        (data) => {
            return [
                data[0] + data[2] + data[4]
            ]
        }
                     },
    {"name": "fun_call", "symbols": [(myLexer.has("identifier") ? {type: "identifier"} : identifier), "__", "arglist"], "postprocess": 
        (data) => {
            return {
                type: "fun_call",
                fun_name: data[0],
                arguments: data[2]
            }
        }
                    },
    {"name": "fun_def", "symbols": [(myLexer.has("fun_keywords") ? {type: "fun_keywords"} : fun_keywords), "__", (myLexer.has("identifier") ? {type: "identifier"} : identifier), "__", "arglist", "__", "codeblock"], "postprocess": 
        (data) => {
            return {
                type: "fun_def",
                fun_name: data[2],
                code: data[6],
                arguments: data[4]
            }
        }
                            },
    {"name": "while", "symbols": [{"literal":"🤗"}, "__", "expr", "__", "codeblock"], "postprocess": 
        (data) => {
            return {
                type: "while",
                cond: data[2],
                code: data[4]
            }
        }
                    },
    {"name": "for_cond", "symbols": [(myLexer.has("number") ? {type: "number"} : number), "_", {"literal":","}, "_", (myLexer.has("number") ? {type: "number"} : number), "_", {"literal":","}, "_", (myLexer.has("number") ? {type: "number"} : number)], "postprocess": 
        (data) => {
            return {
                fVal: data[0],
                sVal: data[4],
                tVal: data[8],
                value: data[0] + data[2] + data[4] + data[6] + data[8]
            }
        }
                    },
    {"name": "for_loop", "symbols": [{"literal":"🌀"}, "__", (myLexer.has("identifier") ? {type: "identifier"} : identifier), "_", {"literal":"➡️"}, "_", "for_cond", "__", "codeblock"], "postprocess": 
        (data) => {
            return {
                type: "for_loop",
                loop_var: data[2],
                iterable: data[6],
                code: data[8]
            }
        }
                    },
    {"name": "power_fun", "symbols": [{"literal":"⚡"}, "_", (myLexer.has("number") ? {type: "number"} : number), "_", {"literal":","}, "_", (myLexer.has("number") ? {type: "number"} : number), "_", {"literal":"❗"}], "postprocess": 
        (data) => {
            return {
                type: "power_fun",
                value: data[2] + data[4] + data[6]
            }
        }
                            },
    {"name": "sqrt", "symbols": [{"literal":"🟥"}, "_", (myLexer.has("number") ? {type: "number"} : number), "_", {"literal":"❗"}], "postprocess": 
        (data) => {
            return {
                type: "sqrt",
                value: data[2],
            }
        }
                            },
    {"name": "log_fun", "symbols": [{"literal":"🪵"}, "_", (myLexer.has("number") ? {type: "number"} : number), "_", {"literal":"❗"}], "postprocess": 
        (data) => {
            return {
                type: "log_fun",
                value: data[2],
            }
        }
                            },
    {"name": "math_fun", "symbols": ["power_fun"], "postprocess": id},
    {"name": "math_fun", "symbols": ["sqrt"], "postprocess": id},
    {"name": "math_fun", "symbols": ["log_fun"], "postprocess": id},
    {"name": "expr", "symbols": ["bin_expr"], "postprocess": id},
    {"name": "expr", "symbols": ["math_fun"], "postprocess": id},
    {"name": "expr", "symbols": ["pi"], "postprocess": id},
    {"name": "expr", "symbols": [(myLexer.has("number") ? {type: "number"} : number), "_", {"literal":","}, "_", (myLexer.has("number") ? {type: "number"} : number)], "postprocess": 
        (data) => {
            return {
                fVal: data[0],
                sVal: data[4],
                value: data[0] + data[2] + data[4]
            }
        }
                },
    {"name": "operator", "symbols": [(myLexer.has("operator") ? {type: "operator"} : operator)], "postprocess": id},
    {"name": "unary_expr", "symbols": [(myLexer.has("string") ? {type: "string"} : string)], "postprocess": id},
    {"name": "unary_expr", "symbols": [(myLexer.has("number") ? {type: "number"} : number)], "postprocess": id},
    {"name": "unary_expr", "symbols": [(myLexer.has("identifier") ? {type: "identifier"} : identifier)], "postprocess": id},
    {"name": "unary_expr", "symbols": ["fun_call"], "postprocess": id},
    {"name": "unary_expr", "symbols": ["boolean"], "postprocess": id},
    {"name": "unary_expr", "symbols": [{"literal":"("}, "expr", {"literal":")"}], "postprocess": data => data[1]},
    {"name": "bin_expr", "symbols": ["unary_expr"], "postprocess": id},
    {"name": "bin_expr", "symbols": ["bin_expr", "_", "operator", "_", "unary_expr"], "postprocess": 
        (data) => {
            return {
                type: "bin_expr",
                left: data[0],
                right: data[4],
                value: data[0] + data[2] + data[4]
            }
        }
                    },
    {"name": "break", "symbols": [{"literal":"🚫"}], "postprocess": 
        (data) => {
            return {
                type: "break"
            }
        }
                },
    {"name": "boolean", "symbols": [{"literal":"💯"}], "postprocess": 
        (data) => {
            return {
                type: "boolean",
                value: true
            }
        }
                    },
    {"name": "boolean", "symbols": [{"literal":"😞"}], "postprocess": 
        (data) => {
            return {
                type: "boolean",
                value: false
            }
        }
                    },
    {"name": "continue", "symbols": [{"literal":"😁"}], "postprocess": 
        (data) => {
            return {
                type: "continue"
            }
        }
                    },
    {"name": "pi", "symbols": [{"literal":"🍕"}], "postprocess": 
        (data) => {
            return {
                type: "PI"
            }
        }
                },
    {"name": "pi", "symbols": [{"literal":"🍰"}], "postprocess": 
        (data) => {
            return {
                type: "PI"
            }
        }
                },
    {"name": "_$ebnf$1", "symbols": []},
    {"name": "_$ebnf$1", "symbols": ["_$ebnf$1", (myLexer.has("WS") ? {type: "WS"} : WS)], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_", "symbols": ["_$ebnf$1"]},
    {"name": "__$ebnf$1", "symbols": [(myLexer.has("WS") ? {type: "WS"} : WS)]},
    {"name": "__$ebnf$1", "symbols": ["__$ebnf$1", (myLexer.has("WS") ? {type: "WS"} : WS)], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "__", "symbols": ["__$ebnf$1"]},
    {"name": "_m$ebnf$1", "symbols": []},
    {"name": "_m$ebnf$1$subexpression$1", "symbols": [(myLexer.has("WS") ? {type: "WS"} : WS)]},
    {"name": "_m$ebnf$1$subexpression$1", "symbols": [(myLexer.has("NL") ? {type: "NL"} : NL)]},
    {"name": "_m$ebnf$1", "symbols": ["_m$ebnf$1", "_m$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_m", "symbols": ["_m$ebnf$1"]},
    {"name": "__m$ebnf$1$subexpression$1", "symbols": [(myLexer.has("WS") ? {type: "WS"} : WS)]},
    {"name": "__m$ebnf$1$subexpression$1", "symbols": [(myLexer.has("NL") ? {type: "NL"} : NL)]},
    {"name": "__m$ebnf$1", "symbols": ["__m$ebnf$1$subexpression$1"]},
    {"name": "__m$ebnf$1$subexpression$2", "symbols": [(myLexer.has("WS") ? {type: "WS"} : WS)]},
    {"name": "__m$ebnf$1$subexpression$2", "symbols": [(myLexer.has("NL") ? {type: "NL"} : NL)]},
    {"name": "__m$ebnf$1", "symbols": ["__m$ebnf$1", "__m$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "__m", "symbols": ["__m$ebnf$1"]},
    {"name": "__lb_$ebnf$1$subexpression$1", "symbols": ["_", (myLexer.has("NL") ? {type: "NL"} : NL)]},
    {"name": "__lb_$ebnf$1", "symbols": ["__lb_$ebnf$1$subexpression$1"]},
    {"name": "__lb_$ebnf$1$subexpression$2", "symbols": ["_", (myLexer.has("NL") ? {type: "NL"} : NL)]},
    {"name": "__lb_$ebnf$1", "symbols": ["__lb_$ebnf$1", "__lb_$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "__lb_", "symbols": ["__lb_$ebnf$1", "__"]},
    {"name": "__lb$ebnf$1", "symbols": [(myLexer.has("NL") ? {type: "NL"} : NL)]},
    {"name": "__lb$ebnf$1", "symbols": ["__lb$ebnf$1", (myLexer.has("NL") ? {type: "NL"} : NL)], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "__lb", "symbols": ["__lb$ebnf$1"]}
]
  , ParserStart: "lines"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();


const funTable = new Set();
const varTable = new Set();

function generateJsForStatements(statements) {
    const lines = [];
    for (let statement of statements) {
        const line = generateJs(statement);
        lines.push(line);
    }
    return lines.join("\n");
}

function generateJs(node) {
    if (node.type === "var_assign") {
        return genVarAssign(node);
    } else if (node.type === "fun_call") {
        return genFunCall(node);
    } else if (node.type === "fun_def") {
        return genFunction(node);
    } else if (node.type === "print_fun") {
        return genPrint(node);
    } else if (node.type === "return_fun") {
        return genReturn(node);
    } else if (node.type === "input_assign") {
        return genInputFun(node);
    } else if (node.type === "power_fun") {
        return genPower(node);
    } else if (node.type === "sqrt") {
        return genSqrt(node);
    } else if (node.type === "log_fun") {
        return genLog(node);
    } else if (node.type === "codeblock") {
        return genCodeBlock(node);
    } else if (node.type === "if_statement") {
        return genIfStatement(node);
    } else if (node.type === "for_loop") {
        return genForLoop(node);
    } else if (node.type === "while") {
        return genWhile(node);
    } else if (node.type === "PI") {
        return `Math.PI`;
    } else if (node.type === "credits") {
        try {
            console.log(chalk.greenBright("Created by"), chalk.underline.greenBright("Harsh Baranwal"));
        } catch (error) {}
    } else if (node.type === "comment") {
        return [];
    } else if (node.type === "string") {
        return node.value;
    } else if (node.type === "bin_expr") {
        return node.value;
    } else if (node.type === "number") {
        return node.value;
    } else if (node.type === "identifier") {
        return node.value;
    } else if (node.type === "break") {
        return "break";
    } else if (node.type === "comma") {
        return ",";
    } else if (node.type === "continue") {
        return "continue";
    } else {
        throw new Error(chalk.red(`Unhandled AST node type: ${node.type}`));
    }
}

let keywords = {
    if: "_if",
    else: "_else",
    while: "_while",
    var: "_var",
    for: "_for",
    return: "_return",
    function: "_function",
    const: "_const",
    let: "_let",
    exports: "_exports",
    break: "_break",
    continue: "_continue",
    switch: "_switch",
    null: "_null",
}

let rkeywords = {
    _if: "if",
    _else: "else",
    _while: "while",
    _var: "var",
    _for: "for",
    _return: "return",
    _function: "function",
    _const: "const",
    _let: "let",
    _exports: "exports",
    _break: "break",
    _continue: "continue",
    _switch: "switch",
    _null: "null"
}

function genPrint(node) {
    var context = node.value.value;
    if (context == undefined) {
        context = node.value;
        context = context.toString();
    }
    context = context.replace(/if|else|while|var|for|return|function|const|let|exports|break|continue|switch|null/gi, function(match) {
        return keywords[match];
    })
    const index = [];

    if (context.indexOf('"') > -1 && context.lastIndexOf('"') > -1) {
        for (let i = 0; i < context.length; i++) {
            if (context[i] === '"') {
                index.push(i);
            }
        }
        var cReplace = "";
        for (let i = 0; i < index.length; i=i+2) {
            cReplace = context.substring(index[i],index[i+1]+1);
            cnew = cReplace.replace(/_if|_else|_while|_var|_for|_return|_function|_const|_let|_exports|_break|_continue|_switch|_null/gi, function(match) {
                return rkeywords[match];
            })
            context = context.replace(cReplace, cnew);
        }
    }
    else if (context.indexOf("'") > -1 && context.lastIndexOf("'") > -1) {
        for (let i = 0; i < context.length; i++) {
            if (context[i] === "'") {
                index.push(i);
            }
        }
        var cReplace = "";
        for (let i = 0; i < index.length; i=i+2) {
            cReplace = context.substring(index[i],index[i+1]+1);
            cnew = cReplace.replace(/_if|_else|_while|_var|_for|_return|_function|_const|_let|_exports|_break|_continue|_switch|_null/gi, function(match) {
                return rkeywords[match];
            })
            context = context.replace(cReplace, cnew);
        }
    }
    var varArray = context.split("🔗");
    for (let i in varArray) {
        var str = varArray[i].trim();
        for (let j in str) {
            if (str[j] == "'") {
                indexVal = varArray.indexOf(varArray[i]);
                varArray.splice(indexVal, 1);
                break;
            }
            else if (str[j] == '"') {
                indexVal = varArray.indexOf(varArray[i]);
                varArray.splice(indexVal, 1);
                break;
            }
        }
    }
    for (let k in varArray) {
        var oneVar = varArray[k].trim();
        if (!varTable.has(oneVar)) {
            throw new Error(chalk.red(`"${oneVar}" variable is not defined.`));
        }
    }
    context = context.replace(/🔗/gi, "+");
    const arrow = ">> "
    // return `console.log(${context});`;
    return `document.getElementById('output-text').innerHTML += "<p>> " + ${context} + "</p>"`;
}

function genVarAssign(node) {
    var main = node.var_name.value;
    const context = generateJs(node.value);
    main = main.replace(/if|else|while|var|for|return|function|const|let|exports|break|continue|switch/gi, function(match) {
        return keywords[match];
    })
    varTable.add(main);
    if (main == "hb" || main == "HB" || main == "hB" || main == "Hb") {
        throw new Error(chalk.red(`You cannot declare "${main}" variable in Emojiscript.`));
    }
    else {
        return `var ${main} = ${context};`;
    }
}

function genFunCall(node) {
    const main = node.fun_name.value;
    const argument = node.arguments.value;
    if (!funTable.has(main)) {
        throw new Error(chalk.red(`Trying to call "${main}" function which is not defined.`));
    }
    else {
        return `${main}(${argument})`;
    }
}

function genReturn(node) {
    const context = node.value.value;
    return `return ${context};`;
}

function genPower(node) {
    const context = node.value;
    return `Math.pow(${context})`;
}

function genSqrt(node) {
    const context = node.value.value;
    return `Math.sqrt(${context})`;
}

function genLog(node) {
    const context = node.value.value;
    return `Math.log(${context})`;
}

function genFunction(node) {
    const funName = node.fun_name.value;
    var argList = node.arguments.value;
    funTable.add(funName);
    if (argList == undefined) {
        argList = node.arguments;
    }
    return [
        `function ${funName}(${argList}) {`,
        indent(node.code.statements.map(node => {
            return generateJs(node);
        }).join("\n")),
        "}"
    ].join("\n");
}

function genIfStatement(node) {
    const condition = node.cond.value;
    const alternate = node.alt ?
        genIfAlternate(node.alt) : "";
    var dataType = undefined;
    if (condition.indexOf("==") > -1 || condition.indexOf(">=") > -1 || condition.indexOf("<=") > -1 || condition.indexOf("!=") > -1 || condition.indexOf(">") > -1 || condition.indexOf("<") > -1) {
        dataType = "boolean"
    }
    if (dataType != "boolean") {
        throw new Error(chalk.red(`Expecting condition ${condition} should be a boolean value.`));
    }
    return [
        `if (${condition}) {`,
        indent(node.code.statements.map(node => {
            return generateJs(node);
        }).join("\n")),
        "}",
        alternate
    ].join("\n");
}

function genIfAlternate(node) {
    return "else {\n" + 
        indent(generateJs(node))
        + "\n}";
}

function genForLoop(node) {
    const varName = node.loop_var.value;
    const fVal = node.iterable.fVal.value;
    const sVal = node.iterable.sVal.value;
    const tVal = node.iterable.tVal.value;
        return [
            `for (let ${varName} = ${fVal}; ${varName} < ${sVal}; ${varName}+=${tVal}) {`,
            indent(node.code.statements.map(node => {
                return generateJs(node);
            }).join("\n")),
            "}",
        ].join("\n");
    // }
}

function genWhile(node) {
    const condition = node.cond.value;
    return [
        `while (${condition}) {`,
        indent(node.code.statements.map(node => {
            return generateJs(node);
        }).join("\n")),
        "}",
    ].join("\n");
}

function genCodeBlock(codeBlock) {
    return codeBlock.statements.map(
        node => generateJs(node))
    .join("\n");
}

function output() {
    const output = document.getElementById('output');
    let editor = document.getElementById('editor');
    let code = editor.value;
    const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));
    parser.feed(code);
    const astJson = JSON.stringify(parser.results[0]);
    
    const statements = JSON.parse(astJson);
    const jsCode = generateJsForStatements(statements);
    output.style.display = "block";
    // document.getElementById('output-text').innerHTML = context;
    // console.log(jsCode);
    var exec = new Function(jsCode);
    return(exec());
}


function indent(text) {
    return text.split("\n").map(line => "    " + line).join("\n");
}



</script>
</html>